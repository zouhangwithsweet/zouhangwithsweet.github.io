{"meta":{"title":"zou hangoo","subtitle":"特别能憋尿","description":"艰难人生，全力前进","author":"zou hang","url":"https://github.com/zouhangwithsweet"},"pages":[{"title":"关于","date":"2018-03-12T01:50:11.000Z","updated":"2018-03-12T01:51:57.601Z","comments":true,"path":"about/index.html","permalink":"https://github.com/zouhangwithsweet/about/index.html","excerpt":"","text":""}],"posts":[{"title":"穷bi薅羊毛之部署玩具 react/vue 单页应用","slug":"穷bi薅羊毛之部署玩具应用","date":"2018-05-18T07:24:00.000Z","updated":"2018-05-18T09:08:01.430Z","comments":true,"path":"2018/05/18/haoyangmao.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/05/18/haoyangmao.html","excerpt":"","text":"记得去年的腾讯云和阿里云推出了一系列优惠活动，白菜价云服务器。当时在v2看到不少大佬上车了，v2站长当时指出“便宜没好货”，果然现在都成“阿里扎”了。当时本人也是蠢蠢欲动，想走一波团购上车，无奈还是要花钱啊。而且我对域名没啥特别的追求，我只希望有个能在线访问的主机即可。 好吧，以上一段话翻译过来就是——花钱是不可能的！ 在下实在是穷的飞起。一直徘徊在薅羊毛的路上，免费的云引擎和数据库是在下的最爱。 我知道第一个免费的云引擎是大名鼎鼎的heroku.com，它提供免费500m的空间，这个东西在国外火了很久，GitHub有个不得了的项目就是部署在heroku.com上的，后来该项目被删了。去年的时候heroku.com的访问速度还是可以的，至少能进去控制台，能部署、重启项目，过完年之后速度没法看了。 实在是没办法只能把眼光放到国内，薅国产羊毛。众所周知，我们可以在GitHub部署纯静态的页面，博客等等；没错我也部署了这个hexo，正如你看到这个，在设置hexo next主题的时候发现了能够存储访问次数的免费容器，也就是我们今天的羊毛猪脚——leancloud.cn（真的不是广告）。这个太（不）吊（要）了（钱），正是我这种前端精（穷）英（bi）需要的。 leancloud的开发版每天提供500m访问流量，不要钱，不少了；10G存储空间；30000次API请求；要啥自行车！因为在下是个前端，只知道点node.js，所有的玩具都是用node跑express的。 鼓掌，开始薅~ 第一步，访问leancloud.cn点击右上角的直接访问控制台。纳尼！不用注册、登录之类的吗？别急，那是下一步。 然后，注册，登录，基操。我们选gayhub作为登录账号，美滋滋。登录后就进去控制台了。看到这个快速入门没？好的，我们不看。直接创建新应用。起个名字test-zz，选择开发版，创建。看看这个云引擎三个字，多么亲切，点击进去。然后点击左侧菜单部署，熟悉的git源码部署点击进去，发现要配置repo，那就去设置菜单设置那我们进去部署repo，go哟呵，不就是git的地址，我们去把源码地址复制上去。顺便把这个Deploy keys配置到你git仓库，很皮。这里有个自定义变量，就是你的express或koa监听的端口，必须设置成3000，重要！弄好之后，自定义你的注意域名。回到部署菜单，部署。 leancloud优秀的地方在于就是能和heroku一样能自动识别你的后台语言。注意点 node.js的项目一定要有package.json express或koa监听的端口，必须设置成3000 默认的启动命令是npm start，这个scripts要配置成你的启动服务器文件。 默认下载的依赖是dependencies，devDependencies不会下载。 下面是实例代码，基于react/vue的spa，前后端分离的静态代码。 package.json123456789101112131415161718192021222324252627282930313233343536373839&#123; \"name\": \"react-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"src/main.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"parcel index.html\", \"build\": \"parcel build index.html --public-url ./\", \"start\": \"node server\" &#125;, \"author\": \"\", \"license\": \"MIT\", \"dependencies\": &#123; \"mobx\": \"^4.2.1\", \"mobx-react\": \"^5.1.2\", \"ra\": \"^0.9.7\", \"re\": \"^0.1.4\", \"react\": \"^16.3.1\", \"react-dom\": \"^16.3.1\", \"react-router\": \"^4.2.0\", \"react-router-dom\": \"^4.2.2\" &#125;, \"devDependencies\": &#123; \"autoprefixer\": \"^8.2.0\", \"babel-eslint\": \"^8.2.2\", \"babel-plugin-transform-class-properties\": \"^6.24.1\", \"babel-preset-env\": \"^1.6.1\", \"babel-preset-react\": \"^6.24.1\", \"babel-preset-stage-0\": \"^6.24.1\", \"eslint\": \"^4.19.1\", \"eslint-config-yelingfeng\": \"0.0.4\", \"eslint-plugin-react\": \"^7.7.0\", \"express\": \"^4.16.3\", \"parcel-bundler\": \"^1.7.0\", \"postcss-modules\": \"^1.1.0\", \"stylus\": \"^0.54.5\" &#125;&#125; server.js1234567891011121314151617181920212223242526272829303132333435const express = require('express')const path = require('path')const axios = require('axios')const app = express()const history = require('connect-history-api-fallback')// 引入第三方路由const proxyConf = require('./config/proxy')const headerConf = &#123; // referer: 'https://www.v2ex.com', // host: 'www.v2ex.com'&#125;let apiRoutes = express.Router()for (let k in proxyConf) &#123; app.get(k, function(req, res) &#123; // console.log(proxyConf[k]) axios.get(proxyConf[k], &#123; headers: headerConf, params: req.query &#125;).then(response =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*') res.json(response.data) &#125;).catch(e =&gt; &#123; console.log(e) &#125;) &#125;)&#125;app.use(history())app.use('/', apiRoutes)app.use(express.static(path.join(__dirname, 'dist')))const port = process.env.PORT || 5000app.listen(port)console.log('server started ' + port) 这里我后端转发一些接口，是自己后端情况而定。dist目录是自己打包好了，你可以放在云引擎上打包。","categories":[],"tags":[{"name":"express","slug":"express","permalink":"https://github.com/zouhangwithsweet/tags/express/"},{"name":"node","slug":"node","permalink":"https://github.com/zouhangwithsweet/tags/node/"},{"name":"云引擎","slug":"云引擎","permalink":"https://github.com/zouhangwithsweet/tags/云引擎/"},{"name":"薅羊毛","slug":"薅羊毛","permalink":"https://github.com/zouhangwithsweet/tags/薅羊毛/"}]},{"title":"拖拽类，一段代码的进化史","slug":"拖拽类，一段代码的进化史","date":"2018-04-24T08:50:54.000Z","updated":"2018-04-24T11:31:41.333Z","comments":true,"path":"2018/04/24/dragable.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/04/24/dragable.html","excerpt":"","text":"最开始学习面向对象编写代码的时候，自己是个菜鸡，2018年了，还是个菜鸡，废话不多说。当年面向对象写法的第一个示例就是实现一个拖拽的类的编写，使用的是构造函数的prototype属性，为实例对象提供方法。最近的工作也是和拖拽类打交道，这段代码也逐渐的进化并应用到多个使用场景，也从prototype的写法进化为ES6 class。 实现拖拽的原理十分简单相信大家也都是烂熟于心，核心就是元素的初始坐标，和鼠标移动终止位置的坐标差值，其中要去除点击位置到元素的左、上边界。 es5 prototype的写法大概是这样的1234567891011121314151617181920212223242526272829303132333435363738function Drag(id)&#123; var _this=this; this.disx=0; this.disy=0; this.oDiv=document.getElementById(id); this.oDiv.onmousedown=function(ev)&#123; _this.fnDown(ev); // 阻止冒泡 return false; &#125;&#125;;// 点击Drag.prototype.fnDown=function (ev)&#123; var _this=this; // 兼容IE var oev=ev||event; // 记录点击位置到元素上边和左边的距离 this.disx=oev.clientX-this.oDiv.offsetLeft; this.disy=oev.clientY-this.oDiv.offsetTop; document.onmousemove=function(ev)&#123; _this.fnMove(ev); &#125;; document.onmouseup=function(ev)&#123; _this.fnUp(ev); &#125;;&#125;;// 移动Drag.prototype.fnMove=function (ev)&#123; var oev=ev||event; // 计算坐标的差值 this.oDiv.style.left=oev.clientX-this.disx+\"px\"; this.oDiv.style.top=oev.clientY-this.disy+\"px\";&#125;;// 销毁绑定事件Drag.prototype.fnUp=function ()&#123; document.onmousemove=null; document.onmouseup=null;&#125;; 有几个注意点 鼠标mousemove，moveuseup事件是在点击事件之后绑定的，鼠标抬起后要销毁事件，不然这两个时间一直存在，导致元素跟着鼠标走。 mousemove，moveuseup事件的绑定最好绑定在window或document上，因为直接绑定在拖拽元素上会出现，鼠标太快超出元素大小，停止移动的现象。 这里的事件绑定使用的是dom1级事件，直接给属性赋值，老代码了不推荐。 现在肯定是要用ES6 class来实现，代码更清晰：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Drag &#123; constructor(el) &#123; this.el = el // 拖拽信息 this.mouse = &#123;&#125; this.mouse.init = false this.init() this.initDrag() &#125; //绝对定位初始化 init() &#123; this.el.style.position = 'absolute' this.el.style.top = `$&#123;this.el.offsetTop&#125;px` this.el.style.left = `$&#123;this.el.offsetLeft&#125;px` &#125; // 拖动初始化 initDrag() &#123; this.el.addEventListener('mousedown', e =&gt; &#123; if (/input|textarea/.test(e.target.tagName.toLowerCase())) return this.mouse.init = true this.mouse.offsetX = e.pageX - this.el.offsetLeft this.mouse.offsetY = e.pageY - this.el.offsetTop // 建立一个函数引用，进行销毁 this.moveHandler = this.move.bind(this) this.upHanler = this.up.bind(this) window.addEventListener('mousemove', this.moveHandler) window.addEventListener('mouseup', this.upHanler) &#125;) &#125; // 拖动 move(e) &#123; if (!this.mouse.init) &#123; return &#125; this.el.style.left = e.pageX - this.mouse.offsetX + 'px' this.el.style.top = e.pageY - this.mouse.offsetY + 'px' &#125; // 松开 up() &#123; this.mouse.init = false console.log('ok') window.removeEventListener('mousemove', this.moveHandler) window.removeEventListener('mouseup', this.upHanler) &#125;&#125; 和老代码相比有几个升级优化的部分 主要给元素添加position:absolute，初始化他的位置，更合理。 使用了e.pageX,e.pageY,获取元素相对视口的位置可用getBoundingClientRect 当元素为input或者textarea时不能拖动。 使用dom2级事件进行事件监听和接触监听 注意在class内默认严格模式，一定要主要上下文的this指向，直接给window绑定一个方法，例如window.addEventListener(&#39;mousemove&#39;, this.move)此时的监听函数的this是指向window的，这显然无法实现拖动，所以要this.move.bind(this)绑定到实例本身。我为什么要建立一个函数引用呢？123// 建立一个函数引用，进行销毁this.moveHandler = this.move.bind(this)this.upHanler = this.up.bind(this) 原因是因为每调用一次Function.bind就会创建一个新的函数，直接调用window.removeEventListener(&#39;mousemove&#39;, this.move.bind(this))是无法销毁你监听事件的，因为这已经是两个函数了，只是内容一样而已。123456function a () &#123;console.log(1)&#125;let b = a.bind(null)let c = a.bind(null)b == a //falsec == b //false ES5中，坚持一个原则：this永远指向最后调用它的那个对象！！！ES6中，箭头函数没有this，它会向父级查找离它最近的一个非箭头函数的this，找不到就是undefined普通函数的this会指向window，严格模式下指向undefined 有几种改变this的方法 new 方法 箭头函数 apply,call,bind 关于this不在一一赘述了，网上大神比我讲的好。下面说下，拖拽类的使用场景： 实现一个vue拖拽指令v-drag，简单易用适合不复杂场景 12345678910111213141516171819202122232425262728export default &#123; name: 'drag', bind: function(el) &#123; var offsetX = 0; var offsetY = 0; function move(e) &#123; el.style.left = e.pageX - offsetX + 'px'; el.style.top = e.pageY - offsetY + 'px'; &#125; function up() &#123; window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); &#125; function down(e) &#123; if (/input|textarea/.test(e.target.tagName.toLowerCase())) return; offsetX = e.pageX - el.offsetLeft; offsetY = e.pageY - el.offsetTop; window.addEventListener('mousemove', move); window.addEventListener('mouseup', up); &#125; el.addEventListener('mousedown', down) &#125;&#125; 结合iscroll5实现拖拽滚动，better-scroll应该也可以 123456789101112131415161718192021222324252627282930313233343536handleMouseMove(e) &#123; if (!this.mouse.init) &#123; return &#125; const deltaX = this.mouse.startX - e.pageX const deltaY = this.mouse.startY - e.pageY this.mouse.cord = [deltaX &gt; 0, deltaY &gt; 0] this.myScroll.scrollTo(this.mouse.scrollerX - deltaX, this.mouse.scrollerY - deltaY)&#125;,handleMouseDown(e) &#123; // 特殊区域处理 const content = this.$refs.scroller.$el if (!e.target.parentNode.contains(content)) return if (e.target.contains(content)) return if (e.target &amp;&amp; e.target.nodeName === 'CANVAS') return if (!this.myScroll) return this.mouse.init = true this.direction = true this.mouse.startX = e.pageX this.mouse.startY = e.pageY this.mouse.scrollerX = this.myScroll.x this.mouse.scrollerY = this.myScroll.y&#125;,handleMouseUp(e) &#123; const content = this.$refs.scroller.$el if (!e.target.parentNode.contains(content)) return if (e.target.contains(content)) return this.mouse.init = false this.direction = false let deltaX = this.myScroll.x - START_X let deltaY = this.myScroll.y - START_Y this.saveScrollerConfig(&#123; x: deltaX, y: deltaY &#125;)&#125; 拖拽进度条等等。 从ES5到ES6，从prototype到class，一段代码的进化史。 HTML5拖放drag，drop待续欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"js/ES6","slug":"js-ES6","permalink":"https://github.com/zouhangwithsweet/tags/js-ES6/"},{"name":"prototype/class","slug":"prototype-class","permalink":"https://github.com/zouhangwithsweet/tags/prototype-class/"}]},{"title":"别人问你http协议，到底是想问什么？（三）<br/>http 方法与ajax封装","slug":"别人问你http协议，到底是想问什么？（三）-br-http-方法与ajax封装","date":"2018-03-24T02:37:39.000Z","updated":"2018-03-24T06:32:19.087Z","comments":true,"path":"2018/03/24/http3.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/24/http3.html","excerpt":"","text":"上一篇文章我们讨论了，状态码304和与http缓存相关的头部，cache-control(res)、expires(res)、etag(res)、If-None-Match(req)、Last-Modified(res)、If-Modified-Since(req)。通过上两篇文章我们会发现，http的响应报文和请求报文简直太重要了，万变不离其中；后端开发人员对http掌控会比前端人员控制大。随着前后分离后，后端同学更是把注意力放在后端的各种业务逻辑，对前端只负责接口。那么问题就来了，有时候你也许会问，为啥调试这个接口要用这种方法？为啥传递参数要这么传？为啥做前端验证这么做？本将通过这几个问题出发，讨论http方法和ajax的封装思路（axios为例）。当然，ajax的封装网上代码无数，本文不会重复早轮子，旨在理解其为什么这么封装，梳理和http 方法之间的联系。 讨论http方法之前，先回顾下http的一些特性^-^。http在1.0版本之前没有持久链接这个概念，每次请求一次就TCP三次握手建立一次连接，很浪费；所以，http1.1增加了1Connection: keep-alive 这个字段，请求头和响应头都有。目前，对于一般浏览器来说，对于同一个域名，大多数浏览器允许同时建立6个持久连接。有时候请求很多，6个连接也忙不过来，就涉及前端性能优化了（面试题）。我们怎么发请求？ajax！（双向常用的是webscokt）我们发请求就用到http方法，本质就是告诉服务器客户端的意图，所以这些方法也是顾名思义的。全部方法如下： 常用的是get（查），post（增），put（改），delete（删）restful风格；get和post经常会被问到有什么区别（面试题），知乎上有很多很回答讲的很细致，我在这里只做个简单对比。 get传递参数使用?k=v&amp;k1&amp;=v2这中直接在请求链接后边加参数值的形式，有的时候需要使用encodeURIComponent函数转义一下字符。 post参数一般有三种formData(qs转参数),Request Payload和上传文件用的multipart/form-data我们封装ajax其实就是参数传递的差别。这些方法里边有个比较特殊的方法options，这个方法经常会出现在CORS跨域请求之前。其目的是判断资源服务器支持哪些请求方法，当然简单请求不会触发CORS预检。 ajax也不用我多说，但是面试经常让手写原生ajax。以XMLHttpRequest来来来一起来一遍：12345678function callBack () &#123; console.log(this.responseText)&#125;let xhr = new XMLHttpRequest()xhr.onload = callBackxhr.open(method, url, true)xhr.send() fetch版123456789101112131415let myHeaders = new Headers()let myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;fetch('flowers.jpg',myInit) .then(function(response) &#123; return response.blob() &#125;) .then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob) myImage.src = objectURL &#125;) 当然这对象和方法有很多的属性和方法，我们也不是经常用原生请求，处理起来比较费劲还有一定的兼容问题，知道是那个意思就行，学有余力查MDN研究即可。我们使用当下最为流行的ajax库axios为例，来封装一个功能强大的，属于自己定制的ajax，看看http方法为这么这么封装。取“一段”axios，搭配一份qs模块：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import axios from 'axios'import qs from 'qs'//生成一个axios实例，它有个一个request方法。const service = axios.create(&#123; baseURL: process.env.MOCK_URL,// 结合node全局变量做dev和build分割 timeout: 180000&#125;)/** * 通用request封装 * @param method * @param url * @param data * @param config * @returns &#123;Promise&#125; */const request = (method, url, data, config = &#123;&#125;) =&gt; &#123; const options = Object.assign(&#123;&#125;, config, &#123; url, method, data &#125;) options.headers = options.headers || &#123;&#125; return new Promise((resolve, reject) =&gt; &#123; // 使用promise给返回结果套一层壳子 service.request(options) // 实例发请求 .then(res =&gt; &#123; const data = res.data const status = res.status if (status === 200) &#123; resolve(data) &#125; resolve(data) // 这里的处理不是很严谨 &#125;).catch(res =&gt; &#123; reject(res) &#125;) &#125;)&#125;// 暴露外部方法export const ajax = &#123; get(url, config) &#123; return request('get', url, null, config) &#125;, delete(url, data, config) &#123; return request('delete', url, data, config) &#125;, head(url, config) &#123; return request('head', url, null, config) &#125;, post(url, data, config = &#123;&#125;) &#123; if (!config.headers) &#123; // 设置请求头参数 config.headers = &#123; 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' &#125; &#125; return request('post', url, qs.stringify(data), config) &#125;, put(url, data, config = &#123;&#125;) &#123; // 设置请求头参数 config.headers = &#123; 'Content-Type': 'application/json; charset=UTF-8' &#125; return request('put', url, data, config) &#125;, patch(url, data, config) &#123; return request('path', url, qs.stringify(data), config) &#125;, setCommonHeader(key, value) &#123; service.defaults.headers.common[key] = value &#125;&#125; 有的时候我们需要token，或者cookies鉴权，其实都是在请求头里边加点东西而已。axios可以通过拦截器来操作。1234567891011service.interceptors.request.use(config =&gt; &#123; // Do something before request is sent if (store.getters.token) &#123; config.headers['X-Token'] = ''// 让每个请求携带token-- ['X-Token']为自定义key 请根据实际情况自行修改 &#125; return config&#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error)&#125;) 有时候我们登录时间太长了要重新登录，就是判断response里边的东西，做个重定向。123456789service.interceptors.response.use(function(response) &#123; //根据条件重定向 if (response.headers.loginstate === 'expired') &#123; // router.push(&#123; path: '/login' &#125;) &#125; return response&#125;, function(error) &#123; return Promise.reject(error)&#125;) 封装代码参考vue-admin项目待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://github.com/zouhangwithsweet/tags/http/"},{"name":"ajax","slug":"ajax","permalink":"https://github.com/zouhangwithsweet/tags/ajax/"}]},{"title":"别人问你http协议，到底是想问什么？（二）<br/>http与缓存","slug":"别人问你http协议，到底是想问什么？（二）-http方法与缓存","date":"2018-03-19T01:15:40.000Z","updated":"2018-03-21T03:20:06.425Z","comments":true,"path":"2018/03/19/http2.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/19/http2.html","excerpt":"","text":"上一篇文章我们讨论了TCP三次握手，http请求头、响应头，Content-Type字段，如何使用node控制这个字段等。我这篇文章将从http状态码入手，讨论写常用的http方法和控制缓存。 我们调试一个接口时，喜欢的数字就是 200，或者说，除了这个数字，别的我们都不喜欢。比如404,401,403,500。状态码的文章数不胜数，本质也是一个关于记忆力的东西。我简单列个常用状态码表即可，如下：1234567891011121314151617100 Continue（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 Switching Protocols（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。----2xx 成功200 OK（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 206 Partial Content（部分内容） 服务器成功处理了部分 GET 请求。----3xx 重定向304 Not Modified（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 ----4xx 客户端错误400 Bad Request（错误请求） 服务器不理解请求的语法。 401 Unauthorized（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 Forbidden（禁止） 服务器拒绝请求。----5xx 服务端错误500 服务器内部错误 在我们自己的服务器之中，你可以任意设置状态码！可能会有坑^-^，看下服务端代码：12res.statusCode = 200 // 你可以任意修改状态码，具体效果，自己实操哈，有惊喜。res.end('我的第一个服务器') 别的码，我们先不看。我们先看 200 与 304 。当浏览器发起一个get请求时，请求成功的话，会返回一个 200 的状态，如下图: 看起来非常完美，但是每次请求都会浪费网络资源，有的东西只请求一次就够了。我们喜欢它能缓存下来，提高访问速度，节省网络资源。 缓存这东西，第一次必须获取到资源后，然后根据返回的信息来告诉如何缓存资源，可能采用的是强缓存，也可能告诉客户端浏览器是协商缓存，这都需要根据响应的header内容来决定的。 在响应头中，和缓存有关的有四个字段。强缓存：不会发起请求。 cache-control(缓存控制): max-age=number(单位是秒)，它规定了一个到期时间，http1.1规范。 expires(到期时间)，它的值是个时间的GMT格式的时间字符串，老规范。 协商缓存：会发起一次请求。 这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 etag，顾名思义，它会把一个资源打上一个 “二维码”，和请求头If-None-Match（如果有的话），就不会重新请求，负责 返回304。具体可见mdn Last-Modified，也是一个时间的GMT格式的时间字符串。和请求头If-Modified-Since（如果有的话）对比，没变返回304 强缓存如何清除呢？这个简单，只需要在URI后边加上query字段即可，也就是我们所谓的版本号。 我来使用node尝试下：config.js123456789module.export = &#123; cache: &#123; maxAge: 600, cacheControl: true, expires: true, lastModified: true, etag: true &#125;&#125; catch.js123456789101112131415161718192021222324252627282930313233const conf = require('../config')// stats为文件服务器内的文件，此处可以忽略function refreshRes(stats, res) &#123; const &#123;maxAge, expires, cacheControl, lastModified, etag&#125; = conf.cache if (expires) &#123; res.setHeader('Expires', (new Date(Date.now() + maxAge * 1000)).toUTCString()) &#125; if (cacheControl) &#123; res.setHeader('Cache-Control', `public, max-age=$&#123;maxAge&#125;`) &#125; if (lastModified) &#123; res.setHeader('Last-Modified', stats.mtime.toUTCString()) &#125; if (etag) &#123; const _et = new Date(stats.mtime).getTime() res.setHeader('ETag', `$&#123;stats.size&#125;-$&#123;_et&#125;`) &#125;&#125;module.exports = (stats, req, res) =&gt; &#123; refreshRes(stats, res) const lastModified = req.headers['if-modified-since'] const etag = req.headers['if-none-match'] if (!lastModified &amp;&amp; !etag) &#123; return false &#125; if (lastModified &amp;&amp; lastModified !== res.getHeader('Last-Modified')) &#123; return false &#125; if (etag &amp;&amp; etag !== res.getHeader('Etage')) &#123; return false &#125; return true&#125; 讲到这里我们梳理下文章内容： 列举了常用的状态码，2xx，3xx，4xx，5xx；其中比较特殊的304是和缓存相关的。401则提醒你，你要拦截你的请求了，在请求头加token字段了。 强缓存缓存与协商缓存；强缓存对应响应头：cache-control单位是秒,expires单位是时间字符串；协商缓存：Etag/If-None-Match；Last-Modified/If-Modified-Since；本质就是对比资源是否过期。强缓存不会发起请求，协商缓存会发起。 番外：结合上一遍文章，我们会发现，http的请求头和响应头和我们开发的关系极其紧密。理解http，除了要理解http常用的状态码之外，其请求实体，响应实体是我们研究的重要部分，也是我们开发的所在的部分。而且，我们会发现，response响应头部字段是可以控制的，我们能人为的返回不同的内容，这也就是后端同学开发接口所做的事情之一。 图片来自知乎张云龙的回答，强烈推荐阅读待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"http缓存","slug":"http缓存","permalink":"https://github.com/zouhangwithsweet/tags/http缓存/"},{"name":"node","slug":"node","permalink":"https://github.com/zouhangwithsweet/tags/node/"}]},{"title":"别人问你http协议，到底是想问什么？","slug":"别人问你http协议，到底是想问你什么？","date":"2018-03-17T00:52:06.000Z","updated":"2018-03-17T05:58:43.101Z","comments":true,"path":"2018/03/17/http1.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/17/http1.html","excerpt":"","text":"本文是阅读《图解http》之后的总结，可能会很长。PS：这本书通俗易懂，适合前端工程师阅读，是非常优秀的http入门书籍。 当你看到这篇文章，我默认你已经稍微了解什么是http(超文本传输协议)，url(统一资源定位符)，常用状态码等。当然这也是我们工作中每天都在接触的 AJAX/接口/API 背后的东西，所以面试的时候经常会被问到 当浏览器输入一个url到页面显示在用户面前，到底发生了什么？ 你了解http吗？（面试题）当然，网上介绍http的文章很多，也比我讲的细也比我讲的好，所以本文将结合 node http 模块，结合代码描述http以加深印象。 http是TCP/IP协议族的一部分，TCP/IP不赘述了（主要是我也不知道），简单来说http是TCP/IP应用层的一部分，这个部分里还有FTP、DNS协议等，其他三个部分 传输层、网络层、链路层不在 http 讨论范围之内。只需要知道，一个由客户端发出的请求,会经过 http协议包装一层，TCP协议包装一层，IP协议包装一层，以太网再包装一层，和发快递是一样的，这个过程称为封装，包装好之后就上路了（通过物理层传输），到达服务器就开始拆开这个快递，从外到内。这个过程任何人无法绝对掌握数据是否可靠，所以要通过TCP三次握手（面试题） 握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）和ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 总结一下就是： 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 话不多说，来用 node/v8.9.3 造个服务器吧。我们一步一步来，这个过程可能有坑，搜索引擎和官方文档更配哦。 1234567891011121314151617181920212223242526// 引入 http 模块const http = require('http')class Server &#123; constructor() &#123; &#125; start() &#123; const serve = http.createServer((req, res) =&gt; &#123; res.end('我的第一个服务器') &#125;) serve.listen(3000, '127.0.0.1',() =&gt; &#123; console.log('我在 http://127.0.0.1:3000 启动了') &#125;) &#125;&#125;// 启动服务器app = new Server()app.start()/** 两行代码版 * const http = require('http') * http.createServer((req, res) =&gt; &#123; * res.end('我的第一个服务器') * &#125;) * .listen(3000) */ 我们启动这个服务器1node server.js 打开 http://127.0.0.1:3000 心怀期待，一打开一看，fxxk！中文乱码了！机智的你马上想到是编码格式的问题。node本身不支持 GBK格式，但是它是支持 UTF-8 的。当然这个编码的问题我们先发一边，我们现在要讨论下，http.createServer 接收的回调函数的两个参数 request、response，请求实体和响应实体。我们在调试接口的过程中，观察浏览器控制台 network 下经会看到一个请求的 公共头，响应头，和请求头。请求头或者叫请求报文首部浏览器给我们做了大量的工作，它包含请求一个接口的重要信息，比如 formData，query 等，类似我们这个例子这样：12345678910GET / HTTP/1.1Host: 127.0.0.1:3000Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: _ga=GA1.1.937303312.1517920872; hibext_instdsigdipv2=1; _gid=GA1.1.34943646.1521164839 公共头是浏览器提供的方便查看，一般都是请求url地址，请求方法，状态码等消息；而响应头或者叫响应报文首部则会有一系列重要的首部字段。常见的如下：12345HTTP/1.1 200 OKContent-Type: text/plain;charset=UTF-8Date: Sat, 17 Mar 2018 02:48:41 GMTConnection: keep-aliveContent-Length: 24 响应头消息会告诉我们用了哪个版本的协议，状态吗和消息’ok’，这个不用多谈。 我们先从响应头入手，这个是我们调试接口的主要部分。发现有个字段Content-Type，机智的你马上想到这个或许能解决我们服务器的乱码问题。直接用我们现在这个服务器，返回的响应头是没有Content-Type(内容类型)这个字段的。而我们的回调函数已经拿到response这个对象了，就意味着我们能直接改造响应头，返回我们想要的样子。我们z在res.end()之前加上这么一个响应字段。1res.setHeader('Content-Type', 'text/plain;charset=UTF-8') 这字段的含义就是，告诉浏览器用什么方式解析返回的结果。这种方式被称为多用途Internet邮件扩展（MIME）类型。我们在post请求提交data也会用到Content-Type。比如使用axios，使用post上传数据是需要根据后端接口要更改headers中的Content-Type。axios默认的数据格式是Request Payload,为JSON对象；有的接口只支持FormData，你需要改为 Content-Type:application/x-www-form-urlencoded，并且使用qs模块把你的数据格式化qs.stringify(data)，使之变为formData的 k1=v1&amp;ke2=v2&amp;k3=v3 的格式；有时候上传不同类型的数据时，请求头的Content-Type: multipart/form-data，也就是传统的form表单submit的效果是一样的。 常用的MIME类型如下：12345678910111213141516171819mimeTypes = &#123; 'css': 'text/css', 'gif': 'image/gif', 'html': 'text/html', 'ico': 'image/jpeg', 'jpeg': 'image/jpeg', 'jpg': 'image/jpeg', 'js': 'application/javascript;charset=UTF-8', 'pdf': 'application/pdf', 'png': 'image/png', 'svg': 'image/svg+xml', 'swf': 'application/x-shockwave-flash', 'tiff': 'image/tiff', 'txt': 'text/plain;charset=UTF-8', 'wav': 'audio/x-wav', 'wma': 'audio/x-ms-wma', 'wmv': 'video/x-ms-wmv', 'xml': 'text/xml'&#125; 讲到这里我们梳理下文章内容： http是TCP/IP协议族的一部分，处于其应用层，是我们最为常用的传输协议；TCP三次握手。 http最要的部分是请求报文（request），响应报文（response），报文首部也就是响应头包含着大量的信息，并有其独有的左右。 MIME和Content-type(内容类型)。 番外：node启动服务器；axios，post请求注意事项，修改请求头Content-Type，qs模块格式化提交数据。 HTTP正确的翻译为 超文本转移协议；现在常称为 超文本传输协议HTML为超文本标记语言 待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/zouhangwithsweet/tags/前端开发/"},{"name":"http","slug":"http","permalink":"https://github.com/zouhangwithsweet/tags/http/"}]},{"title":"关于第三方API跨域那些事","slug":"关于第三方API跨域那些事","date":"2018-03-12T03:49:26.000Z","updated":"2018-03-17T00:57:36.913Z","comments":true,"path":"2018/03/12/corsapi.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/12/corsapi.html","excerpt":"","text":"我们在项目开发中，使用第三方接口难免会遇到一些跨域问题，而跨域这个话题网上已经讨论了无数遍了。常用的有： jsonp cors 服务端反向代理（因为服务端不存在跨域问题） 现在推荐的方式是CORS跨资源共享。在我看来，CORS本质是一种白名单，其关字段为 Access-Control-Allow-Origin，通过标记请求发起站点是否可以访问目标站点的资源，达到跨域的目的。CORS支持所有的http方法，可以说是跨域的本质解决方案。jsonp本质是一个hack，现在不推荐使用了。 那么我们在使用第三方API的时候，API的提供者是怎样处理跨域问题呢？以cnode.js开放平台为例，我们访问一个API接口时，我们发现这些接口的响应头部分包含了Access-Control-Allow-Origin:*，它就是允许所有站点可以跨域访问它的标志。但是有的接口，可能没有这个响应字段。我们在自己造玩具、开发调试的时候怎么处理呢？ 以vue-cli:2.8.2为例，我们可以在config/index.js中修改如下代代码：1234567proxyTable: &#123; '/api': &#123; //将www.exaple.com印射为/apis target: 'http://127.0.0.1:5000', // 接口域名 changeOrigin: true, //是否跨域 secure: false &#125;&#125; 这段代码会为 webpack-dev-server 提供一个代理配置，它内部使用http-proxy-middleware，一个非常强大的node代理工具，这个是可以通过反向代理，实现开发中跨域访问接口的。 那么我们自己来模拟代理要如何来做呢？在学习的过程，我们可以用express作为服务器实现接口转发，这种技术或者叫中间层越来越流行。一般是一传统的Java，PHP，Python, Golang等后台语言作为服务器开发接口，前端通过node中间层来转发接口，返回前端想要的数据格式，极大的提高了接口开发的效率和需求的多样性。现在我们来实现一个简单的express转发接口，实现跨域和返回自己想要的数据。 我们以 https://www.v2ex.com/api 接口为例，这个接口的响应头没有Access-Control-Allow-Origin字段，所以正常使用axios调用此类接口，虽然可以访问到数据，但是axios本身的跨域错误机制，导致我们无法使用其返回的数据。express登场了，我们将使用它来实现接口转发实现跨域。首先我们准备一个路由文件config/proxy.js：12345678module.exports = &#123; '/api/now': 'https://www.v2ex.com/api/topics/latest.json', '/api/hot': 'https://www.v2ex.com/api/topics/hot.json', '/api/node': 'https://www.v2ex.com/api/nodes/show.json', '/api/userinfo': 'https://www.v2ex.com/api/members/show.json', '/api/replies': 'https://www.v2ex.com/api/replies/show.json', '/api/topics': 'https://www.v2ex.com/api/topics/show.json'&#125; 这里我重新定义了接口的名称，你可以把他任意定为你想要的名字。接下来准备一个server.js，也就是我们服务端的主文件：123456789101112131415161718192021222324252627282930313233const express = require('express')const path = require('path')const axios = require('axios')const app = express()// 引入第三方路由const proxyConf = require('./config/proxy')const headerConf = &#123; referer: 'https://www.v2ex.com', host: 'www.v2ex.com'&#125;let apiRoutes = express.Router()for (let k in proxyConf) &#123; app.get(k, function(req, res) &#123; axios.get(proxyConf[k], &#123; headers: headerConf, params: req.query &#125;).then(response =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*') res.json(response.data) &#125;).catch(e =&gt; &#123; console.log(e) &#125;) &#125;)&#125;app.use('/', apiRoutes)app.use(express.static(path.join(__dirname, 'dist')))const port = process.env.PORT || 5000app.listen(port)console.log('server started ' + port) 执行node server.js 这里关键代码为res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)，我们主动给这个简单的http服务器的响应头设置了允许跨域访问，所以你可以通过axios调用http://127.0.0.1:5000/api/now等接口而不会出现跨域报错的问题。在 res.json(response.data)这个操作之前，我们可以根据请求消息req处理返回消息response.data，比如分页，达到我们想要返回的数据的目的。这样我们就模拟了一个反向代理服务器。^-^ 最后，欢迎在GitHub留言，一起学习js，一起进步。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/zouhangwithsweet/tags/vue/"},{"name":"express","slug":"express","permalink":"https://github.com/zouhangwithsweet/tags/express/"},{"name":"cors跨域","slug":"cors跨域","permalink":"https://github.com/zouhangwithsweet/tags/cors跨域/"}]},{"title":"我的第一篇博客","slug":"hello-world","date":"2018-03-10T10:40:48.974Z","updated":"2018-03-14T01:03:29.434Z","comments":true,"path":"2018/03/10/firstBlog.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/10/firstBlog.html","excerpt":"","text":"千里之行 始于足下","categories":[],"tags":[]}]}