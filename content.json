{"meta":{"title":"zou hangoo","subtitle":"特别能憋尿","description":"艰难人生，全力前进","author":"zou hang","url":"https://github.com/zouhangwithsweet"},"pages":[{"title":"关于","date":"2018-03-12T01:50:11.000Z","updated":"2018-03-12T01:51:57.601Z","comments":true,"path":"about/index.html","permalink":"https://github.com/zouhangwithsweet/about/index.html","excerpt":"","text":""}],"posts":[{"title":"别人问你http协议，到底是想问什么？","slug":"别人问你http协议，到底是想问你什么？","date":"2018-03-17T00:52:06.000Z","updated":"2018-03-17T05:58:43.101Z","comments":true,"path":"2018/03/17/http1.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/17/http1.html","excerpt":"","text":"本文是阅读《图解http》之后的总结，可能会很长。PS：这本书通俗易懂，适合前端工程师阅读，是非常优秀的http入门书籍。 当你看到这篇文章，我默认你已经稍微了解什么是http(超文本传输协议)，url(统一资源定位符)，常用状态码等。当然这也是我们工作中每天都在接触的 AJAX/接口/API 背后的东西，所以面试的时候经常会被问到 当浏览器输入一个url到页面显示在用户面前，到底发生了什么？ 你了解http吗？（面试题）当然，网上介绍http的文章很多，也比我讲的细也比我讲的好，所以本文将结合 node http 模块，结合代码描述http以加深印象。 http是TCP/IP协议族的一部分，TCP/IP不赘述了（主要是我也不知道），简单来说http是TCP/IP应用层的一部分，这个部分里还有FTP、DNS协议等，其他三个部分 传输层、网络层、链路层不在 http 讨论范围之内。只需要知道，一个由客户端发出的请求,会经过 http协议包装一层，TCP协议包装一层，IP协议包装一层，以太网再包装一层，和发快递是一样的，这个过程称为封装，包装好之后就上路了（通过物理层传输），到达服务器就开始拆开这个快递，从外到内。这个过程任何人无法绝对掌握数据是否可靠，所以要通过TCP三次握手（面试题） 握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）和ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 总结一下就是： 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 话不多说，来用 node/v8.9.3 造个服务器吧。我们一步一步来，这个过程可能有坑，搜索引擎和官方文档更配哦。 1234567891011121314151617181920212223242526// 引入 http 模块const http = require('http')class Server &#123; constructor() &#123; &#125; start() &#123; const serve = http.createServer((req, res) =&gt; &#123; res.end('我的第一个服务器') &#125;) serve.listen(3000, '127.0.0.1',() =&gt; &#123; console.log('我在 http://127.0.0.1:3000 启动了') &#125;) &#125;&#125;// 启动服务器app = new Server()app.start()/** 两行代码版 * const http = require('http') * http.createServer((req, res) =&gt; &#123; * res.end('我的第一个服务器') * &#125;) * .listen(3000) */ 我们启动这个服务器1node server.js 打开 http://127.0.0.1:3000 心怀期待，一打开一看，fxxk！中文乱码了！机智的你马上想到是编码格式的问题。node本身不支持 GBK格式，但是它是支持 UTF-8 的。当然这个编码的问题我们先发一边，我们现在要讨论下，http.createServer 接收的回调函数的两个参数 request、response，请求实体和响应实体。我们在调试接口的过程中，观察浏览器控制台 network 下经会看到一个请求的 公共头，响应头，和请求头。请求头或者叫请求报文首部浏览器给我们做了大量的工作，它包含请求一个接口的重要信息，比如 formData，query 等，类似我们这个例子这样：12345678910GET / HTTP/1.1Host: 127.0.0.1:3000Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: _ga=GA1.1.937303312.1517920872; hibext_instdsigdipv2=1; _gid=GA1.1.34943646.1521164839 公共头是浏览器提供的方便查看，一般都是请求url地址，请求方法，状态码等消息；而响应头或者叫响应报文首部则会有一系列重要的首部字段。常见的如下：12345HTTP/1.1 200 OKContent-Type: text/plain;charset=UTF-8Date: Sat, 17 Mar 2018 02:48:41 GMTConnection: keep-aliveContent-Length: 24 响应头消息会告诉我们用了哪个版本的协议，状态吗和消息’ok’，这个不用多谈。 我们先从响应头入手，这个是我们调试接口的主要部分。发现有个字段Content-Type，机智的你马上想到这个或许能解决我们服务器的乱码问题。直接用我们现在这个服务器，返回的响应头是没有Content-Type(内容类型)这个字段的。而我们的回调函数已经拿到response这个对象了，就意味着我们能直接改造响应头，返回我们想要的样子。我们z在res.end()之前加上这么一个响应字段。1res.setHeader('Content-Type', 'text/plain;charset=UTF-8') 这字段的含义就是，告诉浏览器用什么方式解析返回的结果。这种方式被称为多用途Internet邮件扩展（MIME）类型。我们在post请求提交data也会用到Content-Type。比如使用axios，使用post上传数据是需要根据后端接口要更改headers中的Content-Type。axios默认的数据格式是Request Payload,为JSON对象；有的接口只支持FormData，你需要改为 Content-Type:application/x-www-form-urlencoded，并且使用qs模块把你的数据格式化qs.stringify(data)，使之变为formData的 k1=v1&amp;ke2=v2&amp;k3=v3 的格式；有时候上传不同类型的数据时，请求头的Content-Type: multipart/form-data，也就是传统的form表单submit的效果是一样的。 常用的MIME类型如下：12345678910111213141516171819mimeTypes = &#123; 'css': 'text/css', 'gif': 'image/gif', 'html': 'text/html', 'ico': 'image/jpeg', 'jpeg': 'image/jpeg', 'jpg': 'image/jpeg', 'js': 'application/javascript;charset=UTF-8', 'pdf': 'application/pdf', 'png': 'image/png', 'svg': 'image/svg+xml', 'swf': 'application/x-shockwave-flash', 'tiff': 'image/tiff', 'txt': 'text/plain;charset=UTF-8', 'wav': 'audio/x-wav', 'wma': 'audio/x-ms-wma', 'wmv': 'video/x-ms-wmv', 'xml': 'text/xml'&#125; 讲到这里我们梳理下文章内容： http是TCP/IP协议族的一部分，处于其应用层，是我们最为常用的传输协议；TCP三次握手。 http最要的部分是请求报文（request），响应报文（response），报文首部也就是响应头包含着大量的信息，并有其独有的左右。 MIME和Content-type(内容类型)。 番外：node启动服务器；axios，post请求注意事项，修改请求头Content-Type，qs模块格式化提交数据。 HTTP正确的翻译为 超文本转移协议；现在常称为 超文本传输协议HTML为超文本标记语言 待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/zouhangwithsweet/tags/前端开发/"},{"name":"http","slug":"http","permalink":"https://github.com/zouhangwithsweet/tags/http/"}]},{"title":"关于第三方API跨域那些事","slug":"关于第三方API跨域那些事","date":"2018-03-12T03:49:26.000Z","updated":"2018-03-17T00:57:36.913Z","comments":true,"path":"2018/03/12/corsapi.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/12/corsapi.html","excerpt":"","text":"我们在项目开发中，使用第三方接口难免会遇到一些跨域问题，而跨域这个话题网上已经讨论了无数遍了。常用的有： jsonp cors 服务端反向代理（因为服务端不存在跨域问题） 现在推荐的方式是CORS跨资源共享。在我看来，CORS本质是一种白名单，其关字段为 Access-Control-Allow-Origin，通过标记请求发起站点是否可以访问目标站点的资源，达到跨域的目的。CORS支持所有的http方法，可以说是跨域的本质解决方案。jsonp本质是一个hack，现在不推荐使用了。 那么我们在使用第三方API的时候，API的提供者是怎样处理跨域问题呢？以cnode.js开放平台为例，我们访问一个API接口时，我们发现这些接口的响应头部分包含了Access-Control-Allow-Origin:*，它就是允许所有站点可以跨域访问它的标志。但是有的接口，可能没有这个响应字段。我们在自己造玩具、开发调试的时候怎么处理呢？ 以vue-cli:2.8.2为例，我们可以在config/index.js中修改如下代代码：1234567proxyTable: &#123; '/api': &#123; //将www.exaple.com印射为/apis target: 'http://127.0.0.1:5000', // 接口域名 changeOrigin: true, //是否跨域 secure: false &#125;&#125; 这段代码会为 webpack-dev-server 提供一个代理配置，它内部使用http-proxy-middleware，一个非常强大的node代理工具，这个是可以通过反向代理，实现开发中跨域访问接口的。 那么我们自己来模拟代理要如何来做呢？在学习的过程，我们可以用express作为服务器实现接口转发，这种技术或者叫中间层越来越流行。一般是一传统的Java，PHP，Python, Golang等后台语言作为服务器开发接口，前端通过node中间层来转发接口，返回前端想要的数据格式，极大的提高了接口开发的效率和需求的多样性。现在我们来实现一个简单的express转发接口，实现跨域和返回自己想要的数据。 我们以 https://www.v2ex.com/api 接口为例，这个接口的响应头没有Access-Control-Allow-Origin字段，所以正常使用axios调用此类接口，虽然可以访问到数据，但是axios本身的跨域错误机制，导致我们无法使用其返回的数据。express登场了，我们将使用它来实现接口转发实现跨域。首先我们准备一个路由文件config/proxy.js：12345678module.exports = &#123; '/api/now': 'https://www.v2ex.com/api/topics/latest.json', '/api/hot': 'https://www.v2ex.com/api/topics/hot.json', '/api/node': 'https://www.v2ex.com/api/nodes/show.json', '/api/userinfo': 'https://www.v2ex.com/api/members/show.json', '/api/replies': 'https://www.v2ex.com/api/replies/show.json', '/api/topics': 'https://www.v2ex.com/api/topics/show.json'&#125; 这里我重新定义了接口的名称，你可以把他任意定为你想要的名字。接下来准备一个server.js，也就是我们服务端的主文件：123456789101112131415161718192021222324252627282930313233const express = require('express')const path = require('path')const axios = require('axios')const app = express()// 引入第三方路由const proxyConf = require('./config/proxy')const headerConf = &#123; referer: 'https://www.v2ex.com', host: 'www.v2ex.com'&#125;let apiRoutes = express.Router()for (let k in proxyConf) &#123; app.get(k, function(req, res) &#123; axios.get(proxyConf[k], &#123; headers: headerConf, params: req.query &#125;).then(response =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*') res.json(response.data) &#125;).catch(e =&gt; &#123; console.log(e) &#125;) &#125;)&#125;app.use('/', apiRoutes)app.use(express.static(path.join(__dirname, 'dist')))const port = process.env.PORT || 5000app.listen(port)console.log('server started ' + port) 执行node server.js 这里关键代码为res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)，我们主动给这个简单的http服务器的响应头设置了允许跨域访问，所以你可以通过axios调用http://127.0.0.1:5000/api/now等接口而不会出现跨域报错的问题。在 res.json(response.data)这个操作之前，我们可以根据请求消息req处理返回消息response.data，比如分页，达到我们想要返回的数据的目的。这样我们就模拟了一个反向代理服务器。^-^ 最后，欢迎在GitHub留言，一起学习js，一起进步。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/zouhangwithsweet/tags/vue/"},{"name":"express","slug":"express","permalink":"https://github.com/zouhangwithsweet/tags/express/"},{"name":"cors跨域","slug":"cors跨域","permalink":"https://github.com/zouhangwithsweet/tags/cors跨域/"}]},{"title":"我的第一篇博客","slug":"hello-world","date":"2018-03-10T10:40:48.974Z","updated":"2018-03-14T01:03:29.434Z","comments":true,"path":"2018/03/10/firstBlog.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/10/firstBlog.html","excerpt":"","text":"千里之行 始于足下","categories":[],"tags":[]}]}