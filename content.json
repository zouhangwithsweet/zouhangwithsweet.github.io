{"meta":{"title":"zou hangoo","subtitle":"特别能憋尿","description":"艰难人生，全力前进","author":"zou hang","url":"https://github.com/zouhangwithsweet"},"pages":[{"title":"关于","date":"2018-03-12T01:50:11.000Z","updated":"2018-03-12T01:51:57.601Z","comments":true,"path":"about/index.html","permalink":"https://github.com/zouhangwithsweet/about/index.html","excerpt":"","text":""}],"posts":[{"title":"别人问你http协议，到底是想问什么？（二）<br/>http与缓存","slug":"别人问你http协议，到底是想问什么？（二）-http方法与缓存","date":"2018-03-19T01:15:40.000Z","updated":"2018-03-19T02:40:35.430Z","comments":true,"path":"2018/03/19/http2.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/19/http2.html","excerpt":"","text":"上一篇文章我们讨论了TCP三次握手，http请求头、响应头，Content-Type字段，如何使用node控制这个字段等。我这篇文章将从http状态码入手，讨论写常用的http方法和控制缓存。 我们调试一个接口时，喜欢的数字就是 200，或者说，除了这个数字，别的我们都不喜欢。比如404,401,403,500。状态码的文章数不胜数，本质也是一个关于记忆力的东西。我简单列个常用状态码表即可，如下：1234567891011121314151617100 Continue（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 Switching Protocols（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。----2xx 成功200 OK（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 206 Partial Content（部分内容） 服务器成功处理了部分 GET 请求。----3xx 重定向304 Not Modified（未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 ----4xx 客户端错误400 Bad Request（错误请求） 服务器不理解请求的语法。 401 Unauthorized（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 Forbidden（禁止） 服务器拒绝请求。----5xx 服务端错误500 服务器内部错误 别的码，我们先不看。我们先看 200 与 304 。当浏览器发起一个get请求时，请求成功的话，会返回一个 200 的状态，如下图: 看起来非常完美，但是每次请求都会浪费网络资源，有的东西只请求一次就够了。我们喜欢它能缓存下来，提高访问速度，节省网络资源。 缓存这东西，第一次必须获取到资源后，然后根据返回的信息来告诉如何缓存资源，可能采用的是强缓存，也可能告诉客户端浏览器是协商缓存，这都需要根据响应的header内容来决定的。 在响应头中，和缓存有关的有四个字段。强缓存：不会发起请求。 catch-control(缓存控制): max-age=number(单位是秒)，它规定了一个到期时间，http1.1规范。 expires(到期时间)，它的值是个时间的GMT格式的时间字符串，老规范。 协商缓存：会发起一次请求。 这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 etag，顾名思义，它会把一个资源打上一个 “二维码”，和请求头If-None-Match（如果有的话），就不会重新请求，负责 返回304。 Last-Modified，也是一个时间的GMT格式的时间字符串。和请求头If-Modified-Since（如果有的话）对比，没变返回304 强缓存如何清除呢？这个简单，只需要在URI后边加上query字段即可，也就是我们所谓的版本号。 我来使用node尝试下：config.js123456789module.export = &#123; cache: &#123; maxAge: 600, cacheControl: true, expires: true, lastModified: true, etag: true &#125;&#125; catch.js123456789101112131415161718192021222324252627282930313233const conf = require('../config')// stats为文件服务器内的文件，此处可以忽略function refreshRes(stats, res) &#123; const &#123;maxAge, expires, cacheControl, lastModified, etag&#125; = conf.cache if (expires) &#123; res.setHeader('Expires', (new Date(Date.now() + maxAge * 1000)).toUTCString()) &#125; if (cacheControl) &#123; res.setHeader('Cache-Control', `public, max-age=$&#123;maxAge&#125;`) &#125; if (lastModified) &#123; res.setHeader('Last-Modified', stats.mtime.toUTCString()) &#125; if (etag) &#123; const _et = new Date(stats.mtime).getTime() res.setHeader('ETag', `$&#123;stats.size&#125;-$&#123;_et&#125;`) &#125;&#125;module.exports = (stats, req, res) =&gt; &#123; refreshRes(stats, res) const lastModified = req.headers['if-modified-since'] const etag = req.headers['if-none-match'] if (!lastModified &amp;&amp; !etag) &#123; return false &#125; if (lastModified &amp;&amp; lastModified !== res.getHeader('Last-Modified')) &#123; return false &#125; if (etag &amp;&amp; etag !== res.getHeader('Etage')) &#123; return false &#125; return true&#125; 待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"http缓存","slug":"http缓存","permalink":"https://github.com/zouhangwithsweet/tags/http缓存/"},{"name":"node","slug":"node","permalink":"https://github.com/zouhangwithsweet/tags/node/"}]},{"title":"别人问你http协议，到底是想问什么？","slug":"别人问你http协议，到底是想问你什么？","date":"2018-03-17T00:52:06.000Z","updated":"2018-03-17T05:58:43.101Z","comments":true,"path":"2018/03/17/http1.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/17/http1.html","excerpt":"","text":"本文是阅读《图解http》之后的总结，可能会很长。PS：这本书通俗易懂，适合前端工程师阅读，是非常优秀的http入门书籍。 当你看到这篇文章，我默认你已经稍微了解什么是http(超文本传输协议)，url(统一资源定位符)，常用状态码等。当然这也是我们工作中每天都在接触的 AJAX/接口/API 背后的东西，所以面试的时候经常会被问到 当浏览器输入一个url到页面显示在用户面前，到底发生了什么？ 你了解http吗？（面试题）当然，网上介绍http的文章很多，也比我讲的细也比我讲的好，所以本文将结合 node http 模块，结合代码描述http以加深印象。 http是TCP/IP协议族的一部分，TCP/IP不赘述了（主要是我也不知道），简单来说http是TCP/IP应用层的一部分，这个部分里还有FTP、DNS协议等，其他三个部分 传输层、网络层、链路层不在 http 讨论范围之内。只需要知道，一个由客户端发出的请求,会经过 http协议包装一层，TCP协议包装一层，IP协议包装一层，以太网再包装一层，和发快递是一样的，这个过程称为封装，包装好之后就上路了（通过物理层传输），到达服务器就开始拆开这个快递，从外到内。这个过程任何人无法绝对掌握数据是否可靠，所以要通过TCP三次握手（面试题） 握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）和ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 总结一下就是： 客户端–发送带有SYN标志的数据包–一次握手–服务端 服务端–发送带有SYN/ACK标志的数据包–二次握手–客户端 客户端–发送带有带有ACK标志的数据包–三次握手–服务端 话不多说，来用 node/v8.9.3 造个服务器吧。我们一步一步来，这个过程可能有坑，搜索引擎和官方文档更配哦。 1234567891011121314151617181920212223242526// 引入 http 模块const http = require('http')class Server &#123; constructor() &#123; &#125; start() &#123; const serve = http.createServer((req, res) =&gt; &#123; res.end('我的第一个服务器') &#125;) serve.listen(3000, '127.0.0.1',() =&gt; &#123; console.log('我在 http://127.0.0.1:3000 启动了') &#125;) &#125;&#125;// 启动服务器app = new Server()app.start()/** 两行代码版 * const http = require('http') * http.createServer((req, res) =&gt; &#123; * res.end('我的第一个服务器') * &#125;) * .listen(3000) */ 我们启动这个服务器1node server.js 打开 http://127.0.0.1:3000 心怀期待，一打开一看，fxxk！中文乱码了！机智的你马上想到是编码格式的问题。node本身不支持 GBK格式，但是它是支持 UTF-8 的。当然这个编码的问题我们先发一边，我们现在要讨论下，http.createServer 接收的回调函数的两个参数 request、response，请求实体和响应实体。我们在调试接口的过程中，观察浏览器控制台 network 下经会看到一个请求的 公共头，响应头，和请求头。请求头或者叫请求报文首部浏览器给我们做了大量的工作，它包含请求一个接口的重要信息，比如 formData，query 等，类似我们这个例子这样：12345678910GET / HTTP/1.1Host: 127.0.0.1:3000Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: _ga=GA1.1.937303312.1517920872; hibext_instdsigdipv2=1; _gid=GA1.1.34943646.1521164839 公共头是浏览器提供的方便查看，一般都是请求url地址，请求方法，状态码等消息；而响应头或者叫响应报文首部则会有一系列重要的首部字段。常见的如下：12345HTTP/1.1 200 OKContent-Type: text/plain;charset=UTF-8Date: Sat, 17 Mar 2018 02:48:41 GMTConnection: keep-aliveContent-Length: 24 响应头消息会告诉我们用了哪个版本的协议，状态吗和消息’ok’，这个不用多谈。 我们先从响应头入手，这个是我们调试接口的主要部分。发现有个字段Content-Type，机智的你马上想到这个或许能解决我们服务器的乱码问题。直接用我们现在这个服务器，返回的响应头是没有Content-Type(内容类型)这个字段的。而我们的回调函数已经拿到response这个对象了，就意味着我们能直接改造响应头，返回我们想要的样子。我们z在res.end()之前加上这么一个响应字段。1res.setHeader('Content-Type', 'text/plain;charset=UTF-8') 这字段的含义就是，告诉浏览器用什么方式解析返回的结果。这种方式被称为多用途Internet邮件扩展（MIME）类型。我们在post请求提交data也会用到Content-Type。比如使用axios，使用post上传数据是需要根据后端接口要更改headers中的Content-Type。axios默认的数据格式是Request Payload,为JSON对象；有的接口只支持FormData，你需要改为 Content-Type:application/x-www-form-urlencoded，并且使用qs模块把你的数据格式化qs.stringify(data)，使之变为formData的 k1=v1&amp;ke2=v2&amp;k3=v3 的格式；有时候上传不同类型的数据时，请求头的Content-Type: multipart/form-data，也就是传统的form表单submit的效果是一样的。 常用的MIME类型如下：12345678910111213141516171819mimeTypes = &#123; 'css': 'text/css', 'gif': 'image/gif', 'html': 'text/html', 'ico': 'image/jpeg', 'jpeg': 'image/jpeg', 'jpg': 'image/jpeg', 'js': 'application/javascript;charset=UTF-8', 'pdf': 'application/pdf', 'png': 'image/png', 'svg': 'image/svg+xml', 'swf': 'application/x-shockwave-flash', 'tiff': 'image/tiff', 'txt': 'text/plain;charset=UTF-8', 'wav': 'audio/x-wav', 'wma': 'audio/x-ms-wma', 'wmv': 'video/x-ms-wmv', 'xml': 'text/xml'&#125; 讲到这里我们梳理下文章内容： http是TCP/IP协议族的一部分，处于其应用层，是我们最为常用的传输协议；TCP三次握手。 http最要的部分是请求报文（request），响应报文（response），报文首部也就是响应头包含着大量的信息，并有其独有的左右。 MIME和Content-type(内容类型)。 番外：node启动服务器；axios，post请求注意事项，修改请求头Content-Type，qs模块格式化提交数据。 HTTP正确的翻译为 超文本转移协议；现在常称为 超文本传输协议HTML为超文本标记语言 待续 欢迎在GitHub给我留言，一起学习，一起进步。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/zouhangwithsweet/tags/前端开发/"},{"name":"http","slug":"http","permalink":"https://github.com/zouhangwithsweet/tags/http/"}]},{"title":"关于第三方API跨域那些事","slug":"关于第三方API跨域那些事","date":"2018-03-12T03:49:26.000Z","updated":"2018-03-17T00:57:36.913Z","comments":true,"path":"2018/03/12/corsapi.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/12/corsapi.html","excerpt":"","text":"我们在项目开发中，使用第三方接口难免会遇到一些跨域问题，而跨域这个话题网上已经讨论了无数遍了。常用的有： jsonp cors 服务端反向代理（因为服务端不存在跨域问题） 现在推荐的方式是CORS跨资源共享。在我看来，CORS本质是一种白名单，其关字段为 Access-Control-Allow-Origin，通过标记请求发起站点是否可以访问目标站点的资源，达到跨域的目的。CORS支持所有的http方法，可以说是跨域的本质解决方案。jsonp本质是一个hack，现在不推荐使用了。 那么我们在使用第三方API的时候，API的提供者是怎样处理跨域问题呢？以cnode.js开放平台为例，我们访问一个API接口时，我们发现这些接口的响应头部分包含了Access-Control-Allow-Origin:*，它就是允许所有站点可以跨域访问它的标志。但是有的接口，可能没有这个响应字段。我们在自己造玩具、开发调试的时候怎么处理呢？ 以vue-cli:2.8.2为例，我们可以在config/index.js中修改如下代代码：1234567proxyTable: &#123; '/api': &#123; //将www.exaple.com印射为/apis target: 'http://127.0.0.1:5000', // 接口域名 changeOrigin: true, //是否跨域 secure: false &#125;&#125; 这段代码会为 webpack-dev-server 提供一个代理配置，它内部使用http-proxy-middleware，一个非常强大的node代理工具，这个是可以通过反向代理，实现开发中跨域访问接口的。 那么我们自己来模拟代理要如何来做呢？在学习的过程，我们可以用express作为服务器实现接口转发，这种技术或者叫中间层越来越流行。一般是一传统的Java，PHP，Python, Golang等后台语言作为服务器开发接口，前端通过node中间层来转发接口，返回前端想要的数据格式，极大的提高了接口开发的效率和需求的多样性。现在我们来实现一个简单的express转发接口，实现跨域和返回自己想要的数据。 我们以 https://www.v2ex.com/api 接口为例，这个接口的响应头没有Access-Control-Allow-Origin字段，所以正常使用axios调用此类接口，虽然可以访问到数据，但是axios本身的跨域错误机制，导致我们无法使用其返回的数据。express登场了，我们将使用它来实现接口转发实现跨域。首先我们准备一个路由文件config/proxy.js：12345678module.exports = &#123; '/api/now': 'https://www.v2ex.com/api/topics/latest.json', '/api/hot': 'https://www.v2ex.com/api/topics/hot.json', '/api/node': 'https://www.v2ex.com/api/nodes/show.json', '/api/userinfo': 'https://www.v2ex.com/api/members/show.json', '/api/replies': 'https://www.v2ex.com/api/replies/show.json', '/api/topics': 'https://www.v2ex.com/api/topics/show.json'&#125; 这里我重新定义了接口的名称，你可以把他任意定为你想要的名字。接下来准备一个server.js，也就是我们服务端的主文件：123456789101112131415161718192021222324252627282930313233const express = require('express')const path = require('path')const axios = require('axios')const app = express()// 引入第三方路由const proxyConf = require('./config/proxy')const headerConf = &#123; referer: 'https://www.v2ex.com', host: 'www.v2ex.com'&#125;let apiRoutes = express.Router()for (let k in proxyConf) &#123; app.get(k, function(req, res) &#123; axios.get(proxyConf[k], &#123; headers: headerConf, params: req.query &#125;).then(response =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', '*') res.json(response.data) &#125;).catch(e =&gt; &#123; console.log(e) &#125;) &#125;)&#125;app.use('/', apiRoutes)app.use(express.static(path.join(__dirname, 'dist')))const port = process.env.PORT || 5000app.listen(port)console.log('server started ' + port) 执行node server.js 这里关键代码为res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)，我们主动给这个简单的http服务器的响应头设置了允许跨域访问，所以你可以通过axios调用http://127.0.0.1:5000/api/now等接口而不会出现跨域报错的问题。在 res.json(response.data)这个操作之前，我们可以根据请求消息req处理返回消息response.data，比如分页，达到我们想要返回的数据的目的。这样我们就模拟了一个反向代理服务器。^-^ 最后，欢迎在GitHub留言，一起学习js，一起进步。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://github.com/zouhangwithsweet/tags/vue/"},{"name":"express","slug":"express","permalink":"https://github.com/zouhangwithsweet/tags/express/"},{"name":"cors跨域","slug":"cors跨域","permalink":"https://github.com/zouhangwithsweet/tags/cors跨域/"}]},{"title":"我的第一篇博客","slug":"hello-world","date":"2018-03-10T10:40:48.974Z","updated":"2018-03-14T01:03:29.434Z","comments":true,"path":"2018/03/10/firstBlog.html","link":"","permalink":"https://github.com/zouhangwithsweet/2018/03/10/firstBlog.html","excerpt":"","text":"千里之行 始于足下","categories":[],"tags":[]}]}